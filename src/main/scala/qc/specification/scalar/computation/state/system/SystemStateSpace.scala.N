package qc.specification.scalar.computation.state.system

import scala.collection.immutable.{Seq}

import math.specification.scalar.{Scalar, ColumnVector, RowVector}

import math.specification.computation.state.{StatefulComputation}

import math.specification.scalar.computation.state.{GeometricColumnVectorSpace}

import math.types.scalar.{Real}

import qc.specification.system.{System}

trait SystemStateSpace[
    S: Scalar,
    M[_]: [_[_]] =>> StatefulComputation[ColumnVector[S], M],
    X: System
] extends GeometricColumnVectorSpace[S, M]:

  //
  // summoned
  //

  // val summonedSystem = summon[System[X]]

  //
  // imported from summoned
  //

  import summonedScalar.{`1`}

  import summonedStatefulComputation.{result, readState, writeState, execWithState}

  //
  // defined
  //

  lazy val Σ: Seq[X]

  val classicalStateIndexOf: X => Int = x => Σ.indexOf(x)

  lazy val dim: Int = Σ.length

  extension (lx: X)
    def δ(rx: X): S =
      import summonedScalar.{`0` => `0s`, `1` => `1s`}
      if (lx == rx) `1s` else `0s`

  val ket: X => ColumnVector[S] = x => basisColumnVector(classicalStateIndexOf(x))

  lazy val kets: Seq[ColumnVector[S]] = Σ map ket

  val isKet: ColumnVector[S] => Boolean = isBasisColumnVector

  val bra: X => RowVector[S] = x => basisRowVector(classicalStateIndexOf(x))

  lazy val bras: Seq[RowVector[S]] = Σ map bra

  val isBra: RowVector[S] => Boolean = isBasisRowVector

  extension (lx: X) def braKet(rx: X): S = bra(lx) o ket(rx)

  val linearKetCombination: Seq[S] => ColumnVector[S] =
    linearBasisColumnVectorCombination

  val linearBraKetCombination: ColumnVector[S] => ColumnVector[S] =
    linearBasisRowVectorBasisColumnVectorCombination

  lazy val observeStatefulComputation: M[X] = measureComputation: cv =>
    result(Σ(cv.seq indexOf `1`))

  val observeState: ColumnVector[S] => X = execWithState(observeStatefulComputation)

  val observeStateTwice: ColumnVector[S] => X =
    execWithState:
      observeStatefulComputation: _ =>
        observeStatefulComputation
