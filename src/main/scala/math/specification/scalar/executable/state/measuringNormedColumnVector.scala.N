package math.specification.scalar.executable.state

import scala.util.{Random}

import math.specification.executable.state.{AsExecutableWithState}

import math.specification.scalar.{Scalar, NormedColumnVector, NormedColumnVectorSpace}

import math.types.scalar.{Real}

import math.specification.executable.state.{AsExecutableWithState}

def measuringNormedColumnVectorExecutable[
    S: Scalar: [_] =>> NormedColumnVectorSpace[S],
    C[_]: [_[_]] =>> AsExecutableWithState[C, NormedColumnVector[S]]
]: Random ?=> C[NormedColumnVector[S]] =

  val summonedRandom = summon[Random]

  val summonedScalar = summon[Scalar[S]]

  val summonedNormedColumnVectorSpace = summon[NormedColumnVectorSpace[S]]

  val summonedComputationWithNormedColumnVectorState =
    summon[AsExecutableWithState[C, NormedColumnVector[S]]]

  import summonedScalar.{scalarNorm}

  import summonedNormedColumnVectorSpace.{indices, basisColumnVectors}

  import summonedComputationWithNormedColumnVectorState.{value, readState, writeState}

  val randomReal = summonedRandom.nextDouble()

  type RealInterval = (Real, Real)

  extension (ri: RealInterval)
    def contains(r: Real): Boolean =
      val br = ri._1
      val er = ri._2
      br <= r && r <= er

  val randomNormBasedBasisIndex: NormedColumnVector[S] => Int = ncv =>
    val normBasedRealIntervals =
      ncv.seq.foldRight(Seq[RealInterval]()) { case (s, ris) =>
        val r = scalarNorm(s)
        (0.0, r) +: (ris map { (br, er) => (br + r, er + r) })
      }
    (indices find { i => normBasedRealIntervals(i) contains randomReal }).get

  readState(()) bind { ncv =>
    val optionalBasisColumnVectorIndex = indices find { i =>
      ncv == basisColumnVectors(i)
    }
    val bcv = basisColumnVectors {
      if (optionalBasisColumnVectorIndex.isDefined) {
        optionalBasisColumnVectorIndex.get
      } else {
        randomNormBasedBasisIndex(ncv)
      }
    }
    writeState(bcv) bind { _ =>
      value(bcv)
    }
  }

def measuringNormedColumnVector[
    S: Scalar: [_] =>> NormedColumnVectorSpace[S],
    C[_]: [_[_]] =>> AsExecutableWithState[C, NormedColumnVector[S]]
]: Random ?=> NormedColumnVector[S] => NormedColumnVector[S] =

  val summonedComputationWithNormedColumnVectorState =
    summon[AsExecutableWithState[C, NormedColumnVector[S]]]

  import summonedComputationWithNormedColumnVectorState.{execute}

  execute(measuringNormedColumnVectorExecutable)

def twiceMeasuringNormedColumnVectorExecutable[
    S: Scalar: [_] =>> NormedColumnVectorSpace[S],
    C[_]: [_[_]] =>> AsExecutableWithState[C, NormedColumnVector[S]]
]: Random ?=> C[NormedColumnVector[S]] =

  val summonedComputationWithNormedColumnVectorState =
    summon[AsExecutableWithState[C, NormedColumnVector[S]]]

  import summonedComputationWithNormedColumnVectorState.{execute}

// bncv =>
  measuringNormedColumnVectorExecutable bind { _ =>
    measuringNormedColumnVectorExecutable
  } // (bncv)

def twiceMeasuringNormedColumnVector[
    S: Scalar: [_] =>> NormedColumnVectorSpace[S],
    C[_]: [_[_]] =>> AsExecutableWithState[C, NormedColumnVector[S]]
]: Random ?=> NormedColumnVector[S] => NormedColumnVector[S] =

  val summonedComputationWithNormedColumnVectorState =
    summon[AsExecutableWithState[C, NormedColumnVector[S]]]

  import summonedComputationWithNormedColumnVectorState.{execute}

  execute(twiceMeasuringNormedColumnVectorExecutable)